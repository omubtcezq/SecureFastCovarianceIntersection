%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%DIF LATEXDIFF DIFFERENCE FILE
%DIF DEL main_submitted_1.tex   Tue May 12 09:13:48 2020
%DIF ADD main.tex               Thu May 14 16:50:08 2020
%2345678901234567890123456789012345678901234567890123456789012345678901234567890
%        1         2         3         4         5         6         7         8

\documentclass[letterpaper, 10 pt, conference]{ieeeconf}  % Comment this line out if you need a4paper

%\documentclass[a4paper, 10pt, conference]{ieeeconf}      % Use this line for a4 paper

\IEEEoverridecommandlockouts                              % This command is only needed if 
                                                          % you want to use the \thanks command

\overrideIEEEmargins                                      % Needed to meet printer requirements.

%In case you encounter the following error:
%Error 1010 The PDF file may be corrupt (unable to open PDF file) OR
%Error 1000 An error occurred while parsing a contents stream. Unable to analyze the PDF file.
%This is a known problem with pdfLaTeX conversion filter. The file cannot be opened with acrobat reader
%Please use one of the alternatives below to circumvent this error by uncommenting one or the other
%\pdfobjcompresslevel=0
%\pdfminorversion=4

% See the \addtolength command later in the file to balance the column lengths
% on the last page of the document

% The following packages can be found on http:\\www.ctan.org
%\usepackage{graphics} % for pdf, bitmapped graphics files
%\usepackage{epsfig} % for postscript graphics files
%\usepackage{mathptmx} % assumes new font selection scheme installed
%\usepackage{times} % assumes new font selection scheme installed
%\usepackage{amsmath} % assumes amsmath package installed
%\usepackage{amssymb}  % assumes amsmath package installed

% Groups consecutive citations together nicely
\usepackage{cite}

% ISAS conventions. Underlined vectors, random vectors, etc.
\usepackage{ISASmacros/isasmathmacros}
%\usepackage{ISASmacros/isastextmacros} % errors?

% Needed to display images generated with Matplotlib nicely
\usepackage{pgf}

% Used to make subfigures and fit 3 figures across the page. Command lets sub references be in parentheses
\usepackage[labelformat=simple]{subcaption}
\renewcommand\thesubfigure{(\alph{subfigure})}

% Keep the figure captions small
\usepackage[font=small]{caption}

% Used to make the last page have even height columns
\usepackage{flushend}

% Condenses everything and also makes it prettier
\usepackage{microtype}

%DIF 56a56-68
% Dodgy method for saving more space %DIF > 
%\usepackage[subtle]{savetrees} %DIF > 
 %DIF > 
\AtBeginDocument{% %DIF > 
   \abovedisplayskip=2pt plus 3pt %DIF > 
   \belowdisplayskip=2pt plus 3pt %DIF > 
   \abovedisplayshortskip=2pt plus 3pt %DIF > 
   \belowdisplayshortskip=2pt plus 3pt %DIF > 
 %DIF > 
   % Use the template Bibtex features %DIF > 
   %\bstctlcite{IEEEexample:BSTcontrol} %DIF > 
} %DIF > 
 %DIF > 
%DIF -------
\title{\LARGE \bf
Secure Fast Covariance Intersection Using Partially Homomorphic and Order Revealing Encryption Schemes
}

\author{Marko Ristic, Benjamin Noack, and Uwe D. Hanebeck% <-this % stops a space
\thanks{Marko Ristic, Benjamin Noack, and Uwe D. Hanebeck are with the Intelligent Sensor-Actuator-Systems Laboratory (ISAS), Institute for Anthropomatics, Karlsruhe Institute of Technology (KIT), Germany.\newline
{\tt\small \{marko.ristic,noack,uwe.hanebeck\}@kit.edu}%
}% <-this % stops a space
}
%DIF PREAMBLE EXTENSION ADDED BY LATEXDIFF
%DIF UNDERLINE PREAMBLE %DIF PREAMBLE
\RequirePackage[normalem]{ulem} %DIF PREAMBLE
\RequirePackage{color}\definecolor{RED}{rgb}{1,0,0}\definecolor{BLUE}{rgb}{0,0,1} %DIF PREAMBLE
\providecommand{\DIFadd}[1]{{\protect\color{blue}\uwave{#1}}} %DIF PREAMBLE
\providecommand{\DIFdel}[1]{{\protect\color{red}\sout{#1}}}                      %DIF PREAMBLE
%DIF SAFE PREAMBLE %DIF PREAMBLE
\providecommand{\DIFaddbegin}{} %DIF PREAMBLE
\providecommand{\DIFaddend}{} %DIF PREAMBLE
\providecommand{\DIFdelbegin}{} %DIF PREAMBLE
\providecommand{\DIFdelend}{} %DIF PREAMBLE
\providecommand{\DIFmodbegin}{} %DIF PREAMBLE
\providecommand{\DIFmodend}{} %DIF PREAMBLE
%DIF FLOATSAFE PREAMBLE %DIF PREAMBLE
\providecommand{\DIFaddFL}[1]{\DIFadd{#1}} %DIF PREAMBLE
\providecommand{\DIFdelFL}[1]{\DIFdel{#1}} %DIF PREAMBLE
\providecommand{\DIFaddbeginFL}{} %DIF PREAMBLE
\providecommand{\DIFaddendFL}{} %DIF PREAMBLE
\providecommand{\DIFdelbeginFL}{} %DIF PREAMBLE
\providecommand{\DIFdelendFL}{} %DIF PREAMBLE
%DIF LISTINGS PREAMBLE %DIF PREAMBLE
\RequirePackage{listings} %DIF PREAMBLE
\RequirePackage{color} %DIF PREAMBLE
\lstdefinelanguage{DIFcode}{ %DIF PREAMBLE
%DIF DIFCODE_UNDERLINE %DIF PREAMBLE
  moredelim=[il][\color{red}\sout]{\%DIF\ <\ }, %DIF PREAMBLE
  moredelim=[il][\color{blue}\uwave]{\%DIF\ >\ } %DIF PREAMBLE
} %DIF PREAMBLE
\lstdefinestyle{DIFverbatimstyle}{ %DIF PREAMBLE
	language=DIFcode, %DIF PREAMBLE
	basicstyle=\ttfamily, %DIF PREAMBLE
	columns=fullflexible, %DIF PREAMBLE
	keepspaces=true %DIF PREAMBLE
} %DIF PREAMBLE
\lstnewenvironment{DIFverbatim}{\lstset{style=DIFverbatimstyle}}{} %DIF PREAMBLE
\lstnewenvironment{DIFverbatim*}{\lstset{style=DIFverbatimstyle,showspaces=true}}{} %DIF PREAMBLE
%DIF END PREAMBLE EXTENSION ADDED BY LATEXDIFF

\begin{document}

\maketitle
\thispagestyle{empty}
\pagestyle{empty}

%        d8888 888               888                             888
%       d88888 888               888                             888
%      d88P888 888               888                             888
%     d88P 888 88888b.  .d8888b  888888 888d888 8888b.   .d8888b 888888
%    d88P  888 888 "88b 88K      888    888P"      "88b d88P"    888
%   d88P   888 888  888 "Y8888b. 888    888    .d888888 888      888
%  d8888888888 888 d88P      X88 Y88b.  888    888  888 Y88b.    Y88b.
% d88P     888 88888P"   88888P'  "Y888 888    "Y888888  "Y8888P  "Y888



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}

Fast covariance intersection is a widespread technique for state estimate fusion in sensor networks when cross-correlations are not known and fast computations are desired. The common requirement of sending estimates from one party to another during fusion means they do not remain locally private. Current secure fusion algorithms rely on encryption schemes that do not provide sufficient flexibility and as a result require, often undesired, excess communication between estimate producers. We propose a novel method of homomorphically computing the fast covariance intersection algorithm on estimates encrypted with a combination of encryption schemes. Using order revealing encryption, we show how \DIFdelbegin \DIFdel{approximate solutions }\DIFdelend \DIFaddbegin \DIFadd{an approximate solution }\DIFaddend to the fast covariance intersection \DIFdelbegin \DIFdel{coefficients }\DIFdelend \DIFaddbegin \DIFadd{weights }\DIFaddend can be computed and combined with partially homomorphic encryptions of estimates, to calculate an encryption of the fused result. The described approach allows secure fusion of any number of private estimates, making third-party cloud processing a viable option when working with sensitive state estimates or when performing estimation over untrusted networks.

\end{abstract}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 8888888          888
%   888            888
%   888            888
%   888   88888b.  888888 888d888 .d88b.
%   888   888 "88b 888    888P"  d88""88b
%   888   888  888 888    888    888  888
%   888   888  888 Y88b.  888    Y88..88P
% 8888888 888  888  "Y888 888     "Y88P"



\section{Introduction}
Sensor data processing and state estimation have been increasingly prevalent in networked systems \DIFdelbegin \DIFdel{\mbox{%DIFAUXCMD
\cite{ligginsDistributedDataFusion2012,chongFortyYearsDistributed2017}}\hspace{0pt}%DIFAUXCMD
}\DIFdelend \DIFaddbegin \DIFadd{\mbox{%DIFAUXCMD
\cite{ligginsDistributedDataFusion2012}}\hspace{0pt}%DIFAUXCMD
}\DIFaddend . Bayesian state estimation has become a particularly common application since the beginning of Kalman estimation theory \DIFdelbegin \DIFdel{\mbox{%DIFAUXCMD
\cite{kalmanNewApproachLinear1960} }\hspace{0pt}%DIFAUXCMD
}\DIFdelend and has led to a large interest in the field of state estimation fusion \DIFdelbegin \DIFdel{\mbox{%DIFAUXCMD
\cite{willnerKalmanFilterAlgorithms1976,chongHierarchicalEstimation1979,chongDistributedTrackingDistributed1986,hashemipourDecentralizedStructuresParallel1988,grimeDataFusionDecentralized1994}}\hspace{0pt}%DIFAUXCMD
}\DIFdelend \DIFaddbegin \DIFadd{\mbox{%DIFAUXCMD
\cite{willnerKalmanFilterAlgorithms1976,hashemipourDecentralizedStructuresParallel1988,chongFortyYearsDistributed2017}}\hspace{0pt}%DIFAUXCMD
}\DIFaddend . Challenges of estimation fusion are closely tied to the handling and merging of estimation error statistics \DIFdelbegin \DIFdel{\mbox{%DIFAUXCMD
\cite{fouratiMultisensorDataFusion2017}}\hspace{0pt}%DIFAUXCMD
}\DIFdelend \DIFaddbegin \DIFadd{\mbox{%DIFAUXCMD
\cite{noackTreatmentDependentInformation2017}}\hspace{0pt}%DIFAUXCMD
}\DIFaddend . Cross-correlations between estimation errors characterize dependencies between local estimates and must be considered when performing consistent or optimal fusion \cite{bar-shalomTracktotrackCorrelationProblem1981,sunMultisensorOptimalInformation2004}. Methods that keep track of \DIFdelbegin \DIFdel{the cross-correlation of errors }\DIFdelend \DIFaddbegin \DIFadd{these cross-correlations }\DIFaddend may require repeated reconstruction \cite{steinbringOptimalSamplebasedFusion2016} and typically add local computational complexity\DIFdelbegin \DIFdel{and limit usability}\DIFdelend . An alternative strategy sees the approximation of \DIFdelbegin \DIFdel{estimate }\DIFdelend error cross-correlation based on conservative suboptimal strategies, and has been implemented in a variety of methods \DIFdelbegin \DIFdel{\mbox{%DIFAUXCMD
\cite{carlsonFederatedFilterFaulttolerant1988,julierNondivergentEstimationAlgorithm1997,sijsStateFusionUnknown2012,noackDecentralizedDataFusion2017,niehsenInformationFusionBased2002,frankenImprovedFastCovariance2005}}\hspace{0pt}%DIFAUXCMD
}\DIFdelend \DIFaddbegin \DIFadd{\mbox{%DIFAUXCMD
\cite{julierNondivergentEstimationAlgorithm1997,noackDecentralizedDataFusion2017,niehsenInformationFusionBased2002}}\hspace{0pt}%DIFAUXCMD
}\DIFaddend . Covariance Intersection (CI) \cite{julierNondivergentEstimationAlgorithm1997} provides one such popular conservative strategy, from which a less computationally expensive method, the Fast Covariance Intersection (FCI) \cite{niehsenInformationFusionBased2002} has been derived. CI is particularly well paired with the information form of the Kalman filter \DIFdelbegin \DIFdel{\mbox{%DIFAUXCMD
\cite{mutambaraDecentralizedEstimationControl1998}}\hspace{0pt}%DIFAUXCMD
}\DIFdelend \DIFaddbegin \DIFadd{\mbox{%DIFAUXCMD
\cite{mutambaraDecentralizedEstimationControl1998,pfaffInformationFormDistributed2017}}\hspace{0pt}%DIFAUXCMD
}\DIFaddend . This algebraically equivalent form of the standard Kalman filter requires the persistent storing of the information vector and information matrix instead of the usual state estimate and estimate covariance, and reduces fusion operations to simple summations. 
\DIFdelbegin \DIFdel{It has been used to subtract common information between estimates when cross-correlations are known \mbox{%DIFAUXCMD
\cite{grimeDataFusionDecentralized1994} }\hspace{0pt}%DIFAUXCMD
and within fully distributed filter implementations \mbox{%DIFAUXCMD
\cite{pfaffInformationFormDistributed2017}}\hspace{0pt}%DIFAUXCMD
.
}\DIFdelend 

\DIFdelbegin \DIFdel{A key step in distributed sensor fusion, and our topic of interest in this paper, is the requirement of transmitting sensor state estimate and covariance information between network nodes for }\DIFdelend \DIFaddbegin \DIFadd{As advancements in distributed algorithms and cloud computing develop, the requirements for privacy and security in such systems have become more apparent \mbox{%DIFAUXCMD
\cite{renSecurityChallengesPublic2012,brennerSecretProgramExecution2011}}\hspace{0pt}%DIFAUXCMD
. In particular for sensor networks, }\DIFaddend the \DIFdelbegin \DIFdel{computation of a final fused result. Network eavesdroppers or curious fusion nodes are not prevented from learning possibly sensitive local state estimates and covariances}\DIFdelend \DIFaddbegin \DIFadd{desire for sensitive hardware information or estimation methodology to remain private may require the privacy of local measurements and estimates as well, and is a non-trivial problem in networks containing eavesdroppers or untrusted parties}\DIFaddend . Encryption has until recently been primarily used to secure information transfer between communicating parties. Common symmetric-key encryption schemes such as AES \DIFdelbegin \DIFdel{\mbox{%DIFAUXCMD
\cite{daemonAnnouncingAdvancedEncryption2001} }\hspace{0pt}%DIFAUXCMD
}\DIFdelend \DIFaddbegin \DIFadd{\mbox{%DIFAUXCMD
\cite{gueronIntelAdvancedEncryption2010} }\hspace{0pt}%DIFAUXCMD
}\DIFaddend are used to encrypt sent information\DIFdelbegin \DIFdel{to its destination}\DIFdelend , and public-key \DIFdelbegin \DIFdel{encryption }\DIFdelend schemes such as RSA \cite{rivestMethodObtainingDigital1978} to distribute symmetric keys. However, recent developments in public-key Homomorphic Encryption (HE) schemes \DIFdelbegin \DIFdel{\mbox{%DIFAUXCMD
\cite{gentryFullyHomomorphicEncryption2009,elgamalPublicKeyCryptosystem1985,paillierPublicKeyCryptosystemsBased1999}}\hspace{0pt}%DIFAUXCMD
}\DIFdelend \DIFaddbegin \DIFadd{\mbox{%DIFAUXCMD
\cite{gentryFullyHomomorphicEncryption2009,stehleFasterFullyHomomorphic2010,elgamalPublicKeyCryptosystem1985,paillierPublicKeyCryptosystemsBased1999}}\hspace{0pt}%DIFAUXCMD
}\DIFaddend , which allow algebraic operations to be performed on encryptions, are leading to \DIFdelbegin \DIFdel{more secure cloud or network }\DIFdelend \DIFaddbegin \DIFadd{novel secure }\DIFaddend applications for signal processing \DIFdelbegin \DIFdel{\mbox{%DIFAUXCMD
\cite{lagendijkEncryptedSignalProcessing2013,alexandruEncryptedCooperativeControla,aristovEncryptedMultisensorInformation2018}}\hspace{0pt}%DIFAUXCMD
. Although implementations of }\DIFdelend \DIFaddbegin \DIFadd{in distributed and cloud computing environments \mbox{%DIFAUXCMD
\cite{lagendijkEncryptedSignalProcessing2012,aristovEncryptedMultisensorInformation2018,farokhiSecurePrivateControl2017,alexandruEncryptedCooperativeControl2019,kogisoCyberSecurityEnhancementNetworked2015,kerschbaumOutsourcedPrivateSet2012}}\hspace{0pt}%DIFAUXCMD
. }\DIFaddend Fully Homomorphic Encryption (FHE) schemes \DIFdelbegin \DIFdel{exist \mbox{%DIFAUXCMD
\cite{gentryImplementingGentryFullyHomomorphic2011}}\hspace{0pt}%DIFAUXCMD
, and }\DIFdelend \DIFaddbegin \DIFadd{\mbox{%DIFAUXCMD
\cite{gentryFullyHomomorphicEncryption2009,stehleFasterFullyHomomorphic2010} }\hspace{0pt}%DIFAUXCMD
}\DIFaddend provide all algebraic operations \DIFdelbegin \DIFdel{on encryptions, }\DIFdelend \DIFaddbegin \DIFadd{over encryptions, and are often theoretically suitable for secure processing in distributed environments. However, }\DIFaddend current implementations are still computationally infeasible for large-scale \DIFdelbegin \DIFdel{signal processing \mbox{%DIFAUXCMD
\cite{duImplementingMLAlgorithms2017,acarSurveyHomomorphicEncryption2018}}\hspace{0pt}%DIFAUXCMD
. Instead, }\DIFdelend \DIFaddbegin \DIFadd{or real-time processing \mbox{%DIFAUXCMD
\cite{acarSurveyHomomorphicEncryption2018}}\hspace{0pt}%DIFAUXCMD
. }\DIFaddend Partially Homomorphic Encryption (PHE) schemes \cite{elgamalPublicKeyCryptosystem1985,paillierPublicKeyCryptosystemsBased1999}, providing \DIFdelbegin \DIFdel{typically only one algebraic operation}\DIFdelend \DIFaddbegin \DIFadd{only a subset of these operations}\DIFaddend , have been a focus for such \DIFdelbegin \DIFdel{processing tasks \mbox{%DIFAUXCMD
\cite{alexandruEncryptedCooperativeControla,aristovEncryptedMultisensorInformation2018}}\hspace{0pt}%DIFAUXCMD
. Most commonly, addition is provided by the Paillier encryption scheme \mbox{%DIFAUXCMD
\cite{paillierPublicKeyCryptosystemsBased1999} }\hspace{0pt}%DIFAUXCMD
due to its speed and simplicity. However, }\DIFdelend \DIFaddbegin \DIFadd{tasks due to their reduced computational requirements. \mbox{%DIFAUXCMD
\cite{aristovEncryptedMultisensorInformation2018} }\hspace{0pt}%DIFAUXCMD
use PHE to run a private distributed Information Filter, \mbox{%DIFAUXCMD
\cite{alexandruEncryptedCooperativeControl2019,farokhiSecurePrivateControl2017} }\hspace{0pt}%DIFAUXCMD
to compute private distributed control aggregation, \mbox{%DIFAUXCMD
\cite{kogisoCyberSecurityEnhancementNetworked2015} }\hspace{0pt}%DIFAUXCMD
for private matrix multiplication, and \mbox{%DIFAUXCMD
\cite{kerschbaumOutsourcedPrivateSet2012} }\hspace{0pt}%DIFAUXCMD
for private set intersection. These works are, however, }\DIFaddend due to the limited operations provided \DIFdelbegin \DIFdel{, securely computable processing algorithms have thus far been }\DIFdelend \DIFaddbegin \DIFadd{by PHE, }\DIFaddend relatively restricted in \DIFdelbegin \DIFdel{complexity and application. The recent development of }\DIFdelend \DIFaddbegin \DIFadd{application. Recent developments in }\DIFaddend new encryption schemes, such as Order Revealing Encryption (ORE) \DIFdelbegin \DIFdel{\mbox{%DIFAUXCMD
\cite{chenettePracticalOrderRevealingEncryption2016,lewiOrderRevealingEncryptionNew2016,bogatovComparativeEvaluationOrderPreserving}}\hspace{0pt}%DIFAUXCMD
, have provided }\DIFdelend \DIFaddbegin \DIFadd{\mbox{%DIFAUXCMD
\cite{chenettePracticalOrderRevealingEncryption2016,lewiOrderRevealingEncryptionNew2016,bogatovComparativeEvaluationOrderPreserving2018}}\hspace{0pt}%DIFAUXCMD
, are now providing }\DIFaddend new light on the possible complexity of \DIFdelbegin \DIFdel{signal processing algorithms that can be computed securely . Thus far, ORE has found little application in the context of signal processing algorithmsor in combination with HE schemes}\DIFdelend \DIFaddbegin \DIFadd{securely computable algorithms}\DIFaddend . In this paper, we \DIFdelbegin \DIFdel{make use of a }\DIFdelend \DIFaddbegin \DIFadd{develop a method for secure FCI fusion, such that local sensor information is kept private, using a }\DIFaddend combination of ORE and PHE schemes \DIFdelbegin \DIFdel{to develop a Secure FCI (SecFCI) fusionmethod that enables us to protect sensor estimates from both eavesdroppers and other algorithm participants}\DIFdelend \DIFaddbegin \DIFadd{only, which has to the best of our knowledge not been achieved without the reliance on computationally expensive FHE schemes.
}

\subsection{\DIFadd{Problem Formulation}} \label{subsec:problem_formulation}
\DIFadd{Our paper is motivated by a key step in multi-sensor fusion, the requirement of transmitting local sensor state estimates and covariance information over a network for the computation of their fused result. In particular, we consider centralized FCI fusion, where a party responsible for many networked sensors capable of computing their local state estimates, wishes to have their fused state estimate and covariance computed securely on an untrusted cloud. The same party may query the cloud fusion center for the fused result at any time. To preserve the privacy of local sensor measurements and state estimates, we aim to provide a secure FCI algorithm such that the fusion center does not learn individual sensor measurements, state estimates, or covariances. This will be achieved by encrypted homomorphic fusion, whereby the untrusted cloud learns only the FCI aggregation weights, as will be shown in section \ref{sec:secfci}.
}

\DIFadd{As we assume the querying party is the owner of all individual sensors, we consider the threat model of network eavesdroppers and a malicious fusion center, with no possible collusion between sensors and the fusion center}\DIFaddend .

\subsection{Notation}
Throughout this paper we will use the following notation. Lowercase characters represent scalars, \DIFdelbegin \DIFdel{lowercase }\DIFdelend \DIFaddbegin \DIFadd{and }\DIFaddend underlined characters, $\vec{x}$, represent vectors. Uppercase bold characters, $\mM$, are \DIFdelbegin \DIFdel{reserved }\DIFdelend for matrices, where \DIFdelbegin \DIFdel{$\mM^\top$ }\DIFdelend \DIFaddbegin \DIFadd{$\mM^{-1}$ }\DIFaddend denotes the matrix \DIFdelbegin \DIFdel{transpose, $\mM^{-1}$ the matrix }\DIFdelend inverse, and $\tr(\cdot)$ the trace function. Covariance matrices will be represented by $\mP$. $\mathcal{E}_{pk}(a)$ and $\mathcal{E}_{ORE,k}(a)$ denote the \DIFaddbegin \DIFadd{encryption of $a$ using the }\DIFaddend public-key $pk$ and ORE key $k$\DIFdelbegin \DIFdel{encryptions of $a$, }\DIFdelend \DIFaddbegin \DIFadd{, respectively, }\DIFaddend and similarly with the decryption functions \DIFdelbegin \DIFdel{$\mathcal{D}_{pk}(\cdot)$ }\DIFdelend \DIFaddbegin \DIFadd{$\mathcal{D}_{sk}(\cdot)$ }\DIFaddend and $\mathcal{D}_{ORE,k}(\cdot)$ \DIFaddbegin \DIFadd{with secret key $sk$}\DIFaddend , where any required real-number encodings of the number $a$ are assumed to be performed. $\mathcal{E}(a)$ and $\mathcal{E}_{ORE}(a)$ may be used for brevity when the encryption keys can be inferred from context. All encryption of vectors and matrices are defined element-wise, with elements given by $\mathcal{E}(\mP_{i,j}) = \mathcal{E}(\mP)_{i,j}$. Sets are represented as $\{\cdot\}$ \DIFdelbegin \DIFdel{while }\DIFdelend \DIFaddbegin \DIFadd{and }\DIFaddend ordered lists with $[\cdot]$.

%  .d8888b. 8888888
% d88P  Y88b  888
% 888    888  888
% 888         888
% 888         888
% 888    888  888
% Y88b  d88P  888
%  "Y8888P" 8888888



\section{Covariance Intersection and Approximations} \label{sec:ci}
Covariance Intersection (CI), introduced in \cite{julierNondivergentEstimationAlgorithm1997}, provides a consistent state estimate fusion algorithm when cross-correlations are not known. The resulting fused estimate $\mean{\vec{x}}$ and \DIFdelbegin \DIFdel{estimate }\DIFdelend covariance $\mP$ can be easily derived from its equations
\begin{equation}
   \mP^{-1}=\sum_{i=1}^{n}\omega_i \mP_i^{-1},\ \mP^{-1} \mean{\vec{x}} =\sum_{i=1}^{n}\omega_i \mP_i^{-1} \mean{\vec{x}}_i\,. \label{eqn:ci_cov_estimate}
\end{equation}
Note that \eqref{eqn:ci_cov_estimate} computes the fusion of the information vectors and information matrices defined in \cite{niehsenInformationFusionBased2002} and reduces the fusion to a \DIFdelbegin \DIFdel{simple }\DIFdelend weighted sum. Values for \DIFaddbegin \DIFadd{weights }\DIFaddend $\omega_i$ must satisfy
\begin{equation}
   \omega_1 + \omega_2 + \cdots + \omega_n = 1,\ 0 \leq \omega_i \leq 1\,, \label{eqn:ci_omega_sum_bound}
\end{equation}
which guarantees consistency of the fused estimates. They are chosen in a way to speed up convergence and minimize error, by minimizing a certain specified property of the resulting fused estimate covariance. One such property, the \DIFdelbegin \DIFdel{fused estimate }\DIFdelend covariance trace, requires the solution to
\begin{equation}
   \argmin_{\omega_1,\dots,\omega_n} \{\tr(\mP)\}\DIFaddbegin \DIFadd{\! }\DIFaddend =\DIFaddbegin \DIFadd{\! }\DIFaddend \argmin_{\omega_1,\dots,\omega_n} \left\{\tr\left(\DIFaddbegin \DIFadd{\!}\DIFaddend \left(\sum_{i=1}^{n}\omega_i \mP_i^{-1}\DIFaddbegin \DIFadd{\!}\DIFaddend \right)^{-1}\right)\DIFaddbegin \DIFadd{\!}\DIFaddend \right\}\DIFdelbegin \DIFdel{\,}\DIFdelend \DIFaddbegin \DIFadd{\!}\DIFaddend . \label{eqn:ci_trace_min}
\end{equation}
However, minimizing this non-linear cost function can be very \DIFdelbegin \DIFdel{costly computationally }\DIFdelend \DIFaddbegin \DIFadd{computationally costly }\DIFaddend and has led to the development of \DIFdelbegin \DIFdel{the non-iterative approximation technique in \mbox{%DIFAUXCMD
\cite{niehsenInformationFusionBased2002}}\hspace{0pt}%DIFAUXCMD
}\DIFdelend \DIFaddbegin \DIFadd{faster approximation techniques}\DIFaddend .


\subsection{Fast Covariance intersection}
The Fast Covariance Intersection (FCI) algorithm from \cite{niehsenInformationFusionBased2002} is a \DIFdelbegin \DIFdel{common method used }\DIFdelend \DIFaddbegin \DIFadd{non-iterative method }\DIFaddend for approximating the solution to \eqref{eqn:ci_trace_min} without the loss of guaranteed consistency. It is computed by defining a new constraint
\begin{equation}
   \omega_i \tr(\mP_i) - \omega_j \tr(\mP_j) = 0,\ i,j=1,2,\dots,n \label{eqn:fci_eq_big}
\end{equation}
on $\omega_i$ and solving the resulting equations instead. In the two sensor case, this results in the solving of
\begin{equation}
   \omega_1 \tr(\mP_1) - \omega_2 \tr(\mP_2) = 0,\ \omega_1 + \omega_2 = 1\,\DIFdelbegin \DIFdel{, }\DIFdelend \DIFaddbegin \DIFadd{. }\DIFaddend \label{eqn:fci_2sen_omega_sum_eq}
\end{equation}
\DIFdelbegin \DIFdel{with analytical solutions given by
}\begin{displaymath}
   \DIFdel{\omega_1 = \frac{\tr(\mP_2)}{\tr(\mP_1)+\tr(\mP_2)},\ \omega_2 = \frac{\tr(\mP_1)}{\tr(\mP_1)+\tr(\mP_2)}\,. \label{eqn:fci_2sen_sol}
}\end{displaymath}%DIFAUXCMD
\DIFdelend When computed for \DIFdelbegin \DIFdel{the }\DIFdelend $n$ \DIFdelbegin \DIFdel{sensor case}\DIFdelend \DIFaddbegin \DIFadd{sensors}\DIFaddend , the highly redundant \DIFdelbegin \DIFdel{constraint }\DIFdelend \eqref{eqn:fci_eq_big} can have its largest linearly independent subset represented by
\begin{equation}
   \omega_i \tr(\mP_i) - \omega_{i+1} \tr(\mP_{i+1}) = 0,\ i=1,2,\dots,n-1\,, \label{eqn:fci_eq}
\end{equation}
and requires the solution to the linear problem
\begin{equation}
   \DIFdelbegin %DIFDELCMD < \begin{bmatrix}
%DIFDELCMD <       \mathcal{P}_1 & -\mathcal{P}_2 & 0 & \cdots & 0 \\
%DIFDELCMD <       0 & \mathcal{P}_2 & -\mathcal{P}_3 & \cdots & 0 \\
%DIFDELCMD <       \vdots & \vdots & \vdots & \ddots & \vdots & \\
%DIFDELCMD <       0 & \cdots & 0 & \mathcal{P}_{n-1} & -\mathcal{P}_n \\
%DIFDELCMD <       1 & \cdots & 1 & 1 & 1 &
%DIFDELCMD <    \end{bmatrix}%%%
\DIFdelend \DIFaddbegin \begingroup
   \setlength\arraycolsep{2pt}
   \begin{bmatrix}
      \mathcal{P}_1 & -\mathcal{P}_2 & 0 & \cdots & 0 \\
      \cdots & \cdots & \cdots & \cdots & \cdots & \\
      0 & \cdots & 0 & \mathcal{P}_{n-1} & -\mathcal{P}_{n} \\
      1 & \cdots & 1 & 1 & 1 &
   \end{bmatrix}\DIFaddend 
   \DIFdelbegin %DIFDELCMD < \begin{bmatrix}
%DIFDELCMD <       \omega_1 \\
%DIFDELCMD <       \omega_2 \\
%DIFDELCMD <       \vdots \\
%DIFDELCMD <       \omega_{n-1} \\
%DIFDELCMD <       \omega_n
%DIFDELCMD <    \end{bmatrix}%%%
\DIFdelend \DIFaddbegin \begin{bmatrix}
      \omega_1 \\
      \vdots \\
      \omega_{n-1} \\
      \omega_{n}
   \end{bmatrix}\DIFaddend 
   =
   \DIFdelbegin %DIFDELCMD < \begin{bmatrix}
%DIFDELCMD <       0 \\
%DIFDELCMD <       0 \\
%DIFDELCMD <       \vdots \\
%DIFDELCMD <       0 \\
%DIFDELCMD <       1
%DIFDELCMD <    \end{bmatrix}%%%
\DIFdelend \DIFaddbegin \begin{bmatrix}
      0 \\
      \vdots \\
      0 \\
      1
   \end{bmatrix}\DIFaddend \,, \label{eqn:fci_eq_sys}
   \DIFaddbegin \endgroup
\DIFaddend \end{equation}
where we let $\mathcal{P}_i = \tr(\mP_i)$.

Our proposed filter aims to solve FCI fusion, namely \eqref{eqn:ci_cov_estimate} and \eqref{eqn:fci_eq_sys}, \DIFdelbegin \DIFdel{homomorphically, such that }\DIFdelend using only encrypted values from each sensor $i$, \DIFdelbegin \DIFdel{we can produce valid encryptions of fused estimates without the need for decryption}\DIFdelend \DIFaddbegin \DIFadd{and leaking only the weight values $\omega_1,\dots,\omega_n$}\DIFaddend .

% 8888888b.  888    888 8888888888       .d8888b.            .d88888b.  8888888b.  8888888888
% 888   Y88b 888    888 888             d88P  "88b          d88P" "Y88b 888   Y88b 888
% 888    888 888    888 888             Y88b. d88P          888     888 888    888 888
% 888   d88P 8888888888 8888888          "Y8888P"           888     888 888   d88P 8888888
% 8888888P"  888    888 888             .d88P88K.d88P       888     888 8888888P"  888
% 888        888    888 888             888"  Y888P"        888     888 888 T88b   888
% 888        888    888 888             Y88b .d8888b        Y88b. .d88P 888  T88b  888
% 888        888    888 8888888888       "Y8888P" Y88b       "Y88888P"  888   T88b 8888888888



\section{Homomorphic and Order Revealing Encryption} \label{sec:encryption}
To achieve a secure solution to the FCI fusion problem, we make use of two types of function-providing encryption schemes. \DIFdelbegin \DIFdel{Public-key additive Partially Homomorphic Encryption (PHE ) schemes \mbox{%DIFAUXCMD
\cite{paillierPublicKeyCryptosystemsBased1999,goldwasserProbabilisticEncryption1984} }\hspace{0pt}%DIFAUXCMD
provide }\DIFdelend \DIFaddbegin \DIFadd{The Paillier additive PHE scheme \mbox{%DIFAUXCMD
\cite{paillierPublicKeyCryptosystemsBased1999} }\hspace{0pt}%DIFAUXCMD
providing }\DIFaddend a single homomorphic addition operation\DIFdelbegin \DIFdel{on cyphertexts such that
}\begin{displaymath}
   \DIFdel{\mathcal{E}(a) \oplus \mathcal{E}(b) = \mathcal{E}(a+b) \label{eqn:phe_eq}
}\end{displaymath}%DIFAUXCMD
\DIFdel{holds. Symmetric-key Order Revealing Encryption (ORE ) schemes \mbox{%DIFAUXCMD
\cite{chenettePracticalOrderRevealingEncryption2016,lewiOrderRevealingEncryptionNew2016} }\hspace{0pt}%DIFAUXCMD
provide }\DIFdelend \DIFaddbegin \DIFadd{, and the Lewi ORE scheme \mbox{%DIFAUXCMD
\cite{lewiOrderRevealingEncryptionNew2016} }\hspace{0pt}%DIFAUXCMD
providing }\DIFaddend a secure comparison function\DIFdelbegin \DIFdel{, allowing the comparison of encrypted values via
}\begin{displaymath}
   \DIFdel{f(\mathcal{E}_{ORE}(a), \mathcal{E}_{ORE}(b)) = \operatorfont{cmp}(a, b)\,. \label{eqn:ore_eq}
}\end{displaymath}%DIFAUXCMD
\DIFdelend \DIFaddbegin \DIFadd{.
}\DIFaddend 

The formal security of encryption schemes consists of a security goal and a formal threat model \cite{katzIntroductionModernCryptography2008}. Indistinguishability of ciphertexts under the adaptive chosen ciphertext attack model (IND-CCA2) is commonly considered the strongest security guarantee\DIFdelbegin \DIFdel{\mbox{%DIFAUXCMD
\cite{bellareRelationsNotionsSecurity1998}}\hspace{0pt}%DIFAUXCMD
. However, }\DIFdelend \DIFaddbegin \DIFadd{, however, }\DIFaddend no homomorphic encryption scheme provides security against \DIFdelbegin \DIFdel{chosen ciphertext attack models }\DIFdelend \DIFaddbegin \DIFadd{IND-CCA2 }\DIFaddend due to their apparent ability to create valid cyphertexts via homomorphic operations. Instead, PHE schemes aim to protect against the weaker assumption of the chosen plaintext attack model (IND-CPA) \cite{chaseSecurityHomomorphicEncryption2017}. Similarly, ORE schemes aim to protect against simulation-based security defined in \cite{chenettePracticalOrderRevealingEncryption2016} or the harder to achieve ordered chosen-plaintext attack model (IND-OCPA).

\subsection{\DIFdelbegin \DIFdel{Additive }\DIFdelend \DIFaddbegin \DIFadd{Paillier }\DIFaddend Partially Homomorphic Encryption \DIFaddbegin \DIFadd{Scheme}\DIFaddend } \label{subsec:paillier}
\DIFdelbegin \DIFdel{The additive PHE scheme we use is the Paillier encryption scheme \mbox{%DIFAUXCMD
\cite{paillierPublicKeyCryptosystemsBased1999} }\hspace{0pt}%DIFAUXCMD
}\DIFdelend \DIFaddbegin \DIFadd{We use the Paillier additive PHE scheme }\DIFaddend due to its implementation simplicity, and computational speed. The Paillier scheme provides two homomorphic operations on encrypted data, \DIFaddbegin \DIFadd{namely
}\DIFaddend \begin{equation}
   \DIFaddbegin \DIFadd{\mathcal{D}_{sk}(}\DIFaddend \mathcal{E}_{pk}(a)\mathcal{E}_{pk}(b) \!\!\pmod{N^{2}}\DIFaddbegin \DIFadd{) }\DIFaddend = \DIFdelbegin \DIFdel{\mathcal{E}_{pk}(}\DIFdelend a + b \!\!\pmod{N} \DIFdelbegin \DIFdel{) }\DIFdelend \label{eqn:paillier_add}
\end{equation}
and
\begin{equation}
   \DIFaddbegin \DIFadd{\mathcal{D}_{sk}(}\DIFaddend \mathcal{E}_{pk}(a)^c \!\!\pmod{N^{2}}\DIFaddbegin \DIFadd{) }\DIFaddend = \DIFdelbegin \DIFdel{\mathcal{E}_{pk}(}\DIFdelend c\cdot a \!\!\pmod{N}\DIFdelbegin \DIFdel{)}\DIFdelend ,\ c \in \mathbb{Z}\DIFdelbegin \DIFdel{^*}\DIFdelend _N\,, \label{eqn:paillier_mult}
\end{equation}
where the modulus $N$ is computed as the product of two large \DIFdelbegin \DIFdel{primes chosen randomly during }\DIFdelend \DIFaddbegin \DIFadd{random primes chosen at }\DIFaddend key-generation. The public and secret keys are shown as $pk$ and $sk$ respectively, and plaintext messages $a,b \in \mathbb{Z}_N$. The Paillier encryption scheme successfully provides security against the IND-CPA model.

\subsection{\DIFaddbegin \DIFadd{Lewi }\DIFaddend Left-Right Order Revealing Encryption} \label{subsec:lewi}
\DIFdelbegin \DIFdel{The OREscheme we have used is Lewi 's }\DIFdelend \DIFaddbegin \DIFadd{For ORE, we use the Lewi }\DIFaddend symmetric-key Left-Right \DIFdelbegin \DIFdel{encryption scheme \mbox{%DIFAUXCMD
\cite{lewiOrderRevealingEncryptionNew2016} }\hspace{0pt}%DIFAUXCMD
that }\DIFdelend \DIFaddbegin \DIFadd{ORE scheme as it }\DIFaddend has the added property of only allowing certain comparisons between cyphertexts. This property can be used to decide which values may not be compared as will be shown in section \ref{sec:secfci} and is described as follows. Two encryption functions allow integers to be encrypted as either a ``Left'' ($L$) or ``Right'' ($R$) encryption by
\begin{equation}
   \DIFdelbegin %DIFDELCMD < \begin{gathered} \label{eqn:lewi_l_r}
%DIFDELCMD <       \operatorfont{enc}^L_{ORE}(k, x) = \mathcal{E}^L_{ORE,k}(x) \\
%DIFDELCMD <       \operatorfont{enc}^R_{ORE}(k, y) = \mathcal{E}^R_{ORE,k}(y)\,,
%DIFDELCMD <    \end{gathered}%%%
\DIFdelend \DIFaddbegin \begin{aligned} \label{eqn:lewi_l_r}
      &\operatorfont{enc}^L_{ORE}(k, x) = \mathcal{E}^L_{ORE,k}(x) \\
      &\operatorfont{enc}^R_{ORE}(k, y) = \mathcal{E}^R_{ORE,k}(y)
   \end{aligned}\DIFaddend \DIFaddbegin \DIFadd{\,,
}\DIFaddend \end{equation}
and only comparisons between an $L$ and an $R$ encryption are possible, by
\begin{equation}
   \operatorfont{cmp}_{ORE}(\mathcal{E}^L_{ORE}(x),\ \mathcal{E}^R_{ORE}(y)) = \operatorfont{cmp}(x, y)\,. \label{eqn:lewi_cmp}
\end{equation}
Note that no decryption function is provided \DIFdelbegin \DIFdel{, }\DIFdelend as only encryptions are required to provide a \DIFdelbegin \DIFdel{means of }\DIFdelend secure comparison. The Lewi ORE encryption scheme provides security against the simulation-based security model \cite{chenettePracticalOrderRevealingEncryption2016} but is not secure against the IND-OCPA model.

\subsection{Real Number Encoding for Homomorphic Encryption} \DIFaddbegin \label{subsec:encoding}
\DIFaddend Both encryption schemes in sections \ref{subsec:paillier} and \ref{subsec:lewi} are defined over positive integers, and the Paillier scheme \DIFdelbegin \DIFdel{with the upper bound $N$ to the size of an encryptable integer }\DIFdelend \DIFaddbegin \DIFadd{bounds the largest encryptable integer by $N-1$}\DIFaddend . Due to the prevalence of real numbers in estimation theory, \DIFdelbegin \DIFdel{typically stored as floating-point numbers in modern-day hardware, an }\DIFdelend integer encoding of real \DIFdelbegin \DIFdel{number values is required for their encryption. This requires handling both negative and fractional numbers }\DIFdelend \DIFaddbegin \DIFadd{numbers is an active field of research that acommpanies encrypted processing \mbox{%DIFAUXCMD
\cite{ziadCryptoImgPrivacyPreserving2016,farokhiSecurePrivateControl2017,cheonHomomorphicEncryptionArithmetic2017}}\hspace{0pt}%DIFAUXCMD
, and a requirement for our estimate fusion algorithm. While some encoding schemes for additive homomorphic encryption provide additional operations such as homomorphic division \mbox{%DIFAUXCMD
\cite{ziadCryptoImgPrivacyPreserving2016}}\hspace{0pt}%DIFAUXCMD
, they typically complicate the homomorphic operations, and in \mbox{%DIFAUXCMD
\cite{ziadCryptoImgPrivacyPreserving2016} }\hspace{0pt}%DIFAUXCMD
leak exponent information of the encrypted real number. We have instead relied on a simplified version of the encoding in \mbox{%DIFAUXCMD
\cite{farokhiSecurePrivateControl2017}}\hspace{0pt}%DIFAUXCMD
}\DIFaddend . 

\DIFdelbegin \DIFdel{Negative numbers can be handled using the common two's complement method of representing negative integers \mbox{%DIFAUXCMD
\cite{liljaDesigningDigitalComputer2004}}\hspace{0pt}%DIFAUXCMD
. This is done by splitting the total range of allowable integers $[0, N)$ in half, and letting the upper half $[\frac{N}{2}, N)$ represent negative integers. From this, we can see that the value of the largest encryptable integer is now given by $N/2-1$ and that the addition of two's complement numbers is automatically preserved due to modulo arithmetic.
   }%DIFDELCMD < 

%DIFDELCMD < %%%
\DIFdel{The handling of fractional numbers proves to be more complicated, due to the homomorphic multiplication property of the Paillier encryption scheme }%DIFDELCMD < \eqref{eqn:paillier_mult}%%%
\DIFdel{. Fractional numbers are represented as integers using the quantising }\DIFdelend \DIFaddbegin \DIFadd{We consider encoding real numbers representable as rational fixed-point numbers consising of a single sign bit, $i$ integer bits and $f$ fractional bits. Each encodable rational number defined by its $b=1+i+f$ bits, is encoded to the positive integer range $[0,2^b)$. This is computed by conversion to the signed }\DIFaddend Q number format \cite{oberstarFixedPointRepresentationFractional2007} \DIFdelbegin \DIFdel{. The encoding of a }\DIFdelend \DIFaddbegin \DIFadd{and is equivalent to the encoding from \mbox{%DIFAUXCMD
\cite{farokhiSecurePrivateControl2017}}\hspace{0pt}%DIFAUXCMD
. The conversion of any }\DIFaddend real number $a$ \DIFdelbegin \DIFdel{, with maximum integer bits $i$ and fractional bits $f$ is represented by an $i+f$ bit long integer $e$, such that the maximum encoding }\DIFdelend \DIFaddbegin \DIFadd{to an encoded fixed-point rational }\DIFaddend is given by
\DIFdelbegin \DIFdel{$2^{(i+f)}-1$. Encoding is performed by
}\DIFdelend \begin{equation}
   e = \floor{2^f a}\DIFaddbegin \pmod{2^b}\DIFaddend \,. \label{eqn:qmn}
\end{equation}
While encoded Q numbers are consistent under addition, \DIFaddbegin \DIFadd{each }\DIFaddend multiplication requires a factor of $1/2^f$ to be removed. As \DIFdelbegin \DIFdel{homomorphic division is not supported by the Paillier encryptionscheme, }\DIFdelend \DIFaddbegin \DIFadd{shown in \mbox{%DIFAUXCMD
\cite{farokhiSecurePrivateControl2017}}\hspace{0pt}%DIFAUXCMD
, cases of encoded multiplication can be computed exactly when using Paillier encryption, however, FCI guarantees only one homomorphic multiplication which we handle when decoding for simplicity. Additionally, knowing }\DIFaddend the number of multiplications \DIFdelbegin \DIFdel{performed on encrypted values must be bounded and handled when decoding. As will be shown in section \ref{sec:secfci}, our fusion method will always require that a single multiplication factor be removed and leads to the decoding of an integer $e$ to a real number $a$ being given by
}\DIFdelend \DIFaddbegin \DIFadd{allows us to relax the requirement for multiplied encoded numbers not to overflow \mbox{%DIFAUXCMD
\cite{farokhiSecurePrivateControl2017}}\hspace{0pt}%DIFAUXCMD
. We decode real numbers representable by $2b$ bits, which corresponds to the range of $b$ bit encoded numbers after a single multiplication. Decoding is defined as the conversion from the signed Q number format and defined by
}\DIFaddend \begin{equation}
   a=
   \DIFdelbegin \DIFdel{\frac{e}{2^{2f}}}\DIFdelend \DIFaddbegin \begin{cases}
      2^{-2f}\left(e \pmod{2^{2b}}\right) & e<2^{2b-1} \\
      2^{-2f}\left((e \pmod{2^{2b}}) - 2^{2b}\right) & e\geq 2^{2b-1}
   \end{cases}\DIFaddend \,. \label{eqn:qmn_mult_decode}
\end{equation}

\DIFdelbegin \DIFdel{While }\DIFdelend \DIFaddbegin \DIFadd{Since }\DIFaddend the largest encryptable integer is given by \DIFdelbegin \DIFdel{$N/2-1$}\DIFdelend \DIFaddbegin \DIFadd{$N-1$}\DIFaddend , the largest encodable real number must account for the additional multiplication factor \DIFdelbegin \DIFdel{in its encoding}\DIFdelend \DIFaddbegin \DIFadd{when encoded}\DIFaddend . Thus, the integer \DIFdelbegin \DIFdel{and fractional }\DIFdelend bits $i$ and \DIFaddbegin \DIFadd{fractional bits }\DIFaddend $f$ must be chosen such that
\begin{equation}
   (2\DIFdelbegin \DIFdel{^{(i+f)}}\DIFdelend \DIFaddbegin \DIFadd{^{(1+i+f)}}\DIFaddend -1)^2 \leq \DIFdelbegin \DIFdel{\frac{N}{2}-1 }\DIFdelend \DIFaddbegin \DIFadd{N-1\,. }\DIFaddend \label{eqn:qmn_max}
\end{equation}
\DIFdelbegin \DIFdel{holds.
}\DIFdelend 

%  .d8888b.                    8888888888 .d8888b. 8888888       .d8888b.
% d88P  Y88b                   888       d88P  Y88b  888        d88P  Y88b
% Y88b.                        888       888    888  888               888
%  "Y888b.    .d88b.   .d8888b 8888888   888         888             .d88P        .d8888b   .d88b.  88888b.
%     "Y88b. d8P  Y8b d88P"    888       888         888         .od888P"         88K      d8P  Y8b 888 "88b
%       "888 88888888 888      888       888    888  888        d88P"      888888 "Y8888b. 88888888 888  888
% Y88b  d88P Y8b.     Y88b.    888       Y88b  d88P  888        888"                   X88 Y8b.     888  888 d8b
%  "Y8888P"   "Y8888   "Y8888P 888        "Y8888P" 8888888      888888888          88888P'  "Y8888  888  888 Y8P



\section{Two-sensor Secure Fast Covariance Intersection} \label{sec:secfci}
In this section, we will introduce the Secure FCI (SecFCI) fusion algorithm for the two sensor case, before extending it to the $n$ sensor case in section \ref{sec:multi_secfci}. The network model we \DIFdelbegin \DIFdel{will consider is one where all }\DIFdelend \DIFaddbegin \DIFadd{consider is described in section \ref{subsec:problem_formulation}, where }\DIFaddend sensors are capable of running local estimators, as well as the PHE and ORE encryption schemes \DIFdelbegin \DIFdel{described in }\DIFdelend \DIFaddbegin \DIFadd{from }\DIFaddend section \ref{sec:encryption}. Each sensor $i$ computes its state estimate $\mean{\vec{x}}_i$ and covariance matrix $\mP_i$ and sends \DIFdelbegin \DIFdel{the }\DIFdelend relevant encrypted information to \DIFdelbegin \DIFdel{a single fusion centerthat computes the fused state estimate and covariance matrix homomorphically. A third, querying party, can request and use the current encrypted fused information from the fusion center at any time. }\DIFdelend \DIFaddbegin \DIFadd{an untrusted cloud fusion center. }\DIFaddend The querying party is the key holding party \DIFdelbegin \DIFdel{in this network }\DIFdelend and generates the PHE public key $pk$, secret key $sk$, and ORE symmetric key $k$. $pk$ is made available to all parties in the network, and $k$ is made available to the sensors only, via any standard public-key scheme such as RSA \cite{rivestMethodObtainingDigital1978}. When encrypting with ORE key $k$, individual sensors are limited to using only $L$ or $R$ ORE encryption to reduce local information leakage. Thus, consecutive ORE encryptions from any sensor cannot be used to infer local information directly, and can only be compared to encryptions from sensors using the alternate ORE encryption.

From \eqref{eqn:ci_cov_estimate}, we can see that both CI fusion equations can be computed on PHE encryptions of sensor information vectors and information matrices, given valid \DIFaddbegin \DIFadd{unencrypted }\DIFaddend values for each $\omega_i$. \DIFdelbegin \DIFdel{In the }\DIFdelend \DIFaddbegin \DIFadd{For this reason, we allow the leakage of all weights $\omega_i$. Thus, in the }\DIFaddend two sensor case, homomorphic fusion is computed by
\begin{equation}
   \mathcal{E}(\mP^{-1}) = \mathcal{E}(\mP^{-1}_1)^{\omega_1}\mathcal{E}(\mP^{-1}_2)^{(1 -\omega_1)} \label{eqn:paillier_ci_cov}
\end{equation}
and
\begin{equation}
   \mathcal{E}(\mP^{-1}\mean{\vec{x}}) = \mathcal{E}(\mP^{-1}_1\mean{\vec{x}}_1)^{\omega_1}\mathcal{E}(\mP^{-1}_2\mean{\vec{x}}_2)^{(1 - \omega_1)}\,, \label{eqn:paillier_ci_estimate}
\end{equation}
where we note that $\omega_2=1-\omega_1$ due to the CI requirement \eqref{eqn:ci_omega_sum_bound}. We also note that in \eqref{eqn:paillier_ci_cov} and \eqref{eqn:paillier_ci_estimate}, each resulting value will have exactly one Q encoding multiplication factor to remove, and can be decoded exactly by using \eqref{eqn:qmn_mult_decode}.

\DIFdelbegin \DIFdel{In the two sensor case, all }\DIFdelend \DIFaddbegin \DIFadd{All }\DIFaddend that remains for computing CI homomorphically\DIFaddbegin \DIFadd{, in the two sensor case, }\DIFaddend is the calculation of parameter $\omega_1$. For this, we approximate the solution to \DIFdelbegin \DIFdel{the FCIfusion algorithm. Since analytical solutions }%DIFDELCMD < \eqref{eqn:fci_2sen_sol} %%%
\DIFdel{require division, they cannot be computed exactly with the given PHE encryptions of sensor information vectors and information matrices. Instead, we discretize }\DIFdelend \DIFaddbegin \DIFadd{FCI. Since our encoding scheme in section \ref{subsec:encoding} does not provide division, the exact result of }\eqref{eqn:fci_2sen_omega_sum_eq} \DIFadd{is approximated. This is accomplished by discretizing }\DIFaddend $\omega_i$ by step-size $s$, such that $s<1$ and $p=1/s \in \mathbb{Z}$, and \DIFdelbegin \DIFdel{approximate }\DIFdelend \DIFaddbegin \DIFadd{approximating }\DIFaddend \eqref{eqn:fci_2sen_omega_sum_eq} with ORE. An ordered discretization of values $\omega^{(x)}$ is defined by
\begin{equation}
   [\omega^{(1)},\dots,\omega^{(p)}] = [0,s,\dots,1-s,1]\,,
\end{equation}
and computed by each sensor $i$. Each $\omega^{(x)}$ is multiplied by $\tr(\mP_i)$ and encrypted with ORE key $k$. Sensor $1$'s list is defined by 
\begin{equation}
   [\mathcal{E}^L_{ORE}(\omega^{(1)}\tr(\mP_1)),\dots,\mathcal{E}^L_{ORE}(\omega^{(p)}\tr(\mP_1))]\,, \DIFdelbegin %DIFDELCMD < \label{eqn:sen0_ore_list}
%DIFDELCMD < %%%
\DIFdelend \DIFaddbegin \label{eqn:sen1_ore_list}
\DIFaddend \end{equation}
and similarly sensor $2$'s by
\begin{equation}
   [\mathcal{E}^R_{ORE}(\omega^{(1)}\tr(\mP_2)),\dots,\mathcal{E}^R_{ORE}(\omega^{(p)}\tr(\mP_2))]\,. \DIFdelbegin %DIFDELCMD < \label{eqn:sen1_ore_list}
%DIFDELCMD < %%%
\DIFdelend \DIFaddbegin \label{eqn:sen2_ore_list}
\DIFaddend \end{equation}
Note that Sensor $1$ uses only $L$ ORE while sensor $2$ uses only $R$ ORE and that both lists are ordered. Lists \DIFdelbegin %DIFDELCMD < \eqref{eqn:sen0_ore_list} %%%
\DIFdel{and }\DIFdelend \eqref{eqn:sen1_ore_list} \DIFaddbegin \DIFadd{and }\eqref{eqn:sen2_ore_list} \DIFaddend are sent alongside PHE encryptions of local information vector and information matrix estimates to the fusion center which uses them to estimate the FCI values of $\omega_1$ and $\omega_2$.

From \eqref{eqn:fci_2sen_omega_sum_eq} we know that $\omega_1$ must satisfy
\begin{equation}
   \omega_1 \tr(\mP_1) = (1-\omega_1)\tr(\mP_2)\,. \label{eqn:secfci_2sen_intersect}
\end{equation}
If we reverse \DIFdelbegin %DIFDELCMD < \eqref{eqn:sen1_ore_list}%%%
\DIFdelend \DIFaddbegin \eqref{eqn:sen2_ore_list}\DIFaddend , we obtain \DIFdelbegin \DIFdel{the equivalent list
}\begin{displaymath}
   [\DIFdel{\mathcal{E}^R_{ORE}((1-\omega^{(1)})\tr(\mP_2)),\dots,\mathcal{E}^R_{ORE}((1-\omega^{(p)})\tr(\mP_2))}] \DIFdel{\label{eqn:sen2_ore_rev_list}
}\end{displaymath}%DIFAUXCMD
\DIFdel{which when }\DIFdelend \DIFaddbegin \DIFadd{a list equivalent to one with values $\mathcal{E}^R_{ORE}((1-\omega^{(x)})\tr(\mP_2))$ for each discretization step $x$. When the reversed list is }\DIFaddend decrypted and plotted over \DIFdelbegin %DIFDELCMD < \eqref{eqn:sen0_ore_list} %%%
\DIFdel{shows that the intersecting point }\DIFdelend \DIFaddbegin \eqref{eqn:sen1_ore_list} \DIFadd{the intersection }\DIFaddend gives the solution to \eqref{eqn:secfci_2sen_intersect} and therefore, \eqref{eqn:fci_2sen_omega_sum_eq}. However, \eqref{eqn:sen1_ore_list} and \DIFdelbegin %DIFDELCMD < \eqref{eqn:sen2_ore_rev_list} %%%
\DIFdelend \DIFaddbegin \DIFadd{reversed }\eqref{eqn:sen2_ore_list} \DIFaddend consist of $L$ and $R$ ORE encryptions respectively, and the intersection must be approximated by locating \DIFdelbegin \DIFdel{the }\DIFdelend consecutive $\omega^{(x)}$ discretisations where the sign of comparisons changes. This can be seen in Fig. \ref{fig:2_sensor_sol}, and can be performed in \DIFdelbegin \DIFdel{$O(log(p))$ by }\DIFdelend \DIFaddbegin \DIFadd{$O(\log{p})$ ORE comparisons using }\DIFaddend a binary search.
\begin{figure}[tb]
   \vspace{-5pt}
   \begin{center}
      \input{images/2_sensors.pgf}
   \end{center}
   \DIFdelbeginFL %DIFDELCMD < \vspace{-10pt}
%DIFDELCMD <    %%%
\DIFdelendFL \DIFaddbeginFL \vspace{-15pt}
   \DIFaddendFL \caption{Approximation of $\omega_1$ with discretisation step-size $s=0.1$. Only comparisons between line points are used.}
   \vspace{-\baselineskip}
   \label{fig:2_sensor_sol}
\end{figure}
Consecutive $\omega^{(x)}$ and $\omega^{(x+1)}$ for which list comparisons differ can be used to estimate the true intersection, and $\omega_1$, by
\begin{equation}
   \omega_1 \approx \DIFdelbegin \DIFdel{\frac{1}{2}}\DIFdelend \DIFaddbegin \DIFadd{0.5}\DIFaddend (\omega^{(x)} + \omega^{(x+1)})\,. \label{eqn:secfci_2sen_omega}
\end{equation}
In the case a comparison returns equality, the exact value of $\omega^{(x)}$ can be taken to be $\omega_1$.

The fusion center can then use its values for $\omega_1$ and $\omega_2 = 1-\omega_1$ and the received PHE encryptions of local information vectors and information matrices to compute \eqref{eqn:paillier_ci_cov} and \eqref{eqn:paillier_ci_estimate}.

%  .d8888b.                    8888888888 .d8888b. 8888888
% d88P  Y88b                   888       d88P  Y88b  888
% Y88b.                        888       888    888  888
%  "Y888b.    .d88b.   .d8888b 8888888   888         888
%     "Y88b. d8P  Y8b d88P"    888       888         888
%       "888 88888888 888      888       888    888  888
% Y88b  d88P Y8b.     Y88b.    888       Y88b  d88P  888
%  "Y8888P"   "Y8888   "Y8888P 888        "Y8888P" 8888888



\section{Multi-sensor Secure Fast Covariance Intersection} \label{sec:multi_secfci}
When computing the SecFCI fusion for $n$ sensors, we solve \eqref{eqn:ci_cov_estimate} homomorphically by computing
\begin{equation}
   \mathcal{E}(\mP^{-1}) = \mathcal{E}(\mP^{-1}_1)^{\omega_1}\cdots\mathcal{E}(\mP^{-1}_n)^{\omega_n} \label{eqn:n_sen_paillier_ci_cov}
\end{equation}
and
\begin{equation}
   \mathcal{E}(\mP^{-1}\mean{\vec{x}}) = \mathcal{E}(\mP^{-1}_1\mean{\vec{x}}_1)^{\omega_1}\cdots\mathcal{E}(\mP^{-1}_n\mean{\vec{x}}_n)^{\omega_n}\,. \label{eqn:n_sen_paillier_ci_estimate}
\end{equation}
As with the two sensor case, encoded results from \eqref{eqn:n_sen_paillier_ci_cov} and \eqref{eqn:n_sen_paillier_ci_estimate} contain exactly one multiplication factor to remove and can be decoded exactly with \eqref{eqn:qmn_mult_decode}. Again we are just left with computing the \DIFaddbegin \DIFadd{plaintext }\DIFaddend weights $\omega_1,\dots,\omega_n$.

Our approach to the $n$ sensor case is to solve each $n-1$ conditions in \eqref{eqn:fci_eq} using the two sensor method, and combining partial solutions to compute the final result. When we consider a Euclidean dimension for each $\omega_i$, partial solutions can be considered geometrically as hyperplanes of $n-2$ dimension, over the $n-1$ dimensional solution space given by \eqref{eqn:ci_omega_sum_bound}. 

This can be visualized in the three sensor case, which requires solving partial solutions
\begin{equation}
   \omega_1 \tr(\mP_1) - \omega_2 \tr(\mP_2) = 0,\ \omega_1+\omega_2=1-\omega_3 \label{eqn:3_sensor_partial_sol_1}
\end{equation}
and
\begin{equation}
   \omega_2 \tr(\mP_2) - \omega_3 \tr(\mP_3) = 0,\ \omega_2+\omega_3=1-\omega_1\,. \label{eqn:3_sensor_partial_sol_2}
\end{equation}
We can use the two sensor method from section \ref{sec:secfci} to solve \eqref{eqn:3_sensor_partial_sol_1} exactly when $\omega_3=0$, and know that when $\omega_3=1$, then $\omega_1=\omega_2=0$. These two points are enough to define the two-dimensional partial solution \eqref{eqn:3_sensor_partial_sol_1} which can be seen plotted over the possible solution space in Fig. \ref{fig:3_sensor_partial_sol}. Fig. \ref{fig:3_sensor_partial_sols} shows both partial solutions \eqref{eqn:3_sensor_partial_sol_1} and \eqref{eqn:3_sensor_partial_sol_2} plotted over the solution space.
\begin{figure*}[tb]
   \begin{subfigure}[t]{0.3\textwidth}
      \DIFaddbeginFL \vspace{-5pt}
      \DIFaddendFL \begin{center}
         \input{images/partial_sol1.pgf}
      \end{center}
      \DIFaddbeginFL \vspace{-10pt}
      \DIFaddendFL \caption{Partial solution to \eqref{eqn:3_sensor_partial_sol_1}.}
      \label{fig:3_sensor_partial_sol}
   \end{subfigure}
   ~
   \begin{subfigure}[t]{0.3\textwidth}
      \DIFaddbeginFL \vspace{-5pt}
      \DIFaddendFL \begin{center}
         \input{images/partial_sols.pgf}
      \end{center}
      \DIFaddbeginFL \vspace{-10pt}
      \DIFaddendFL \caption{Partial solutions to \eqref{eqn:3_sensor_partial_sol_1} and \eqref{eqn:3_sensor_partial_sol_2}.}
      \label{fig:3_sensor_partial_sols}
   \end{subfigure}
   ~
   \begin{subfigure}[t]{0.3\textwidth}
      \DIFaddbeginFL \vspace{-5pt}
      \DIFaddendFL \begin{center}
         \input{images/partial_sol_planes.pgf}
      \end{center}
      \DIFaddbeginFL \vspace{-10pt}
      \DIFaddendFL \caption{Partial solutions as planes\DIFdelbeginFL \DIFdelFL{perpendicular to the solution space}\DIFdelendFL .}
      \label{fig:3sen_planes}
   \end{subfigure}
   \caption{Partial solutions over $\omega_1$, $\omega_2$, and $\omega_3$ solution space.}
   \vspace{-\baselineskip}
   \label{fig:partial_sols_and_planes}
\end{figure*}
The final solution from all partial solutions is computed by finding their intersection. This can be seen in Fig. \ref{fig:3_sensor_partial_sols} as the intersection of the $(\omega_1,\omega_2)$ and $(\omega_2,\omega_3)$ partial solution lines.

To simplify computing the partial solution intersection, we define equivalent planes for each \DIFdelbegin \DIFdel{partial solution}\DIFdelend \DIFaddbegin \DIFadd{of the partial solutions}\DIFaddend , perpendicular to the solution space, in the form
\begin{equation}
   a_1\omega_1 + a_2\omega_2 +a_3\omega_3 + a_4 = 0\,, \label{eqn:3sen_plane_eq}
\end{equation}
and solve the resulting linear system for finding the intersection of all planes and the solution space. This is given by
\begin{equation}
   \begin{bmatrix}
      a_1^{(1)} & a_2^{(1)} & a_3^{(1)} \\
      a_1^{(2)} & a_2^{(2)} & a_3^{(2)} \\
      1 & 1 & 1
   \end{bmatrix}
   \begin{bmatrix}
      \omega_1 \\
      \omega_2 \\
      \omega_3
   \end{bmatrix}
   =
   \DIFdelbegin %DIFDELCMD < \begin{bmatrix}
%DIFDELCMD <       a_4^{(1)} \\
%DIFDELCMD <       a_4^{(2)} \\
%DIFDELCMD <       1
%DIFDELCMD <    \end{bmatrix}%%%
\DIFdelend \DIFaddbegin \begin{bmatrix}
      a_3^{(1)} \\
      a_4^{(2)} \\
      1
   \end{bmatrix}\DIFaddend \,, \label{eqn:3sen_plane_sol_eq}
\end{equation}
where $a_i^{(j)}$ denotes parameter $i$ of partial solution $j$\DIFdelbegin \DIFdel{.
}\DIFdelend \DIFaddbegin \DIFadd{, and has been shown visually in Fig. \ref{fig:3sen_planes}.
}\DIFaddend 

In the $n$ sensor case, we can similarly solve partial solutions by first using the method from section \ref{sec:secfci} to solve \DIFdelbegin \DIFdel{an equation }\DIFdelend \DIFaddbegin \DIFadd{equations }\DIFaddend with two parameters $\omega_k$ and $\omega_{k+1}$ when letting all $\omega_i=0,\ i\neq k,k+1$\DIFdelbegin \DIFdel{, and can compute a remaining point for each }\DIFdelend \DIFaddbegin \DIFadd{. For each equation we can then compute remaining partial solution points at }\DIFaddend $\omega_i=1,\ i\neq k,k+1$ with $\omega_j=0,\ j\neq i$. Perpendicular hyperplanes can then be similarly defined in the form 
\begin{equation}
   a_1\omega_1 + \dots +a_n\omega_n + a_{n+1} = 0\,. \label{eqn:nsen_plane_eq}
\end{equation}
Due to their inherent orthogonality, \DIFaddbegin \DIFadd{and that all meaningful covariance traces are strictly positive, the }\DIFaddend $n-1$ partial solution hyperplanes are guaranteed to intersect at exactly one point\DIFdelbegin \DIFdel{when at most $1$ sensor has $\tr(\mP_i)=0$}\DIFdelend . The hyperplane intersection results in the linear system 
\begin{equation}
   \DIFdelbegin %DIFDELCMD < \begin{bmatrix}
%DIFDELCMD <       a_1^{(1)} & a_2^{(1)} & \cdots & a_n^{(1)} \\
%DIFDELCMD <       a_1^{(2)} & a_2^{(2)} & \cdots & a_n^{(2)} \\
%DIFDELCMD <       \vdots & \vdots & \ddots & \vdots \\
%DIFDELCMD <       a_1^{(n-1)} & a_2^{(n-1)} & \cdots & a_n^{(n-1)} \\
%DIFDELCMD <       1 & 1 & \cdots & 1
%DIFDELCMD <    \end{bmatrix}%%%
\DIFdelend \DIFaddbegin \begingroup
   \setlength\arraycolsep{2pt}
   \begin{bmatrix}
      a_1^{(1)} & a_2^{(1)} & \cdots & a_{n}^{(1)} \\
      \vdots & \vdots & \ddots & \vdots \\
      a_1^{(n-1)} & a_2^{(n-1)} & \cdots & a_{n}^{(n-1)} \\
      1 & 1 & \cdots & 1
   \end{bmatrix}\DIFaddend 
   \DIFdelbegin %DIFDELCMD < \begin{bmatrix}
%DIFDELCMD <       \omega_1 \\
%DIFDELCMD <       \omega_2 \\
%DIFDELCMD <       \vdots \\
%DIFDELCMD <       \omega_{n-1} \\
%DIFDELCMD <       \omega_n
%DIFDELCMD <    \end{bmatrix}%%%
\DIFdelend \DIFaddbegin \begin{bmatrix}
      \omega_1 \\
      \vdots \\
      \omega_{n-1} \\
      \omega_{n}
   \end{bmatrix}\DIFaddend 
   =
   \DIFdelbegin %DIFDELCMD < \begin{bmatrix}
%DIFDELCMD <       a_{n+1}^{(1)} \\
%DIFDELCMD <       a_{n+1}^{(2)} \\
%DIFDELCMD <       \vdots \\
%DIFDELCMD <       a_{n+1}^{(n-1)} \\
%DIFDELCMD <       1
%DIFDELCMD <    \end{bmatrix}%%%
\DIFdelend \DIFaddbegin \begin{bmatrix}
      a_{n+1}^{(1)} \\
      \vdots \\
      a_{n+1}^{(n-1)} \\
      1
   \end{bmatrix}\DIFaddend \,, \label{eqn:hyperplane_sol_eq}
   \DIFaddbegin \endgroup
\DIFaddend \end{equation}
and gives the solution to the SecFCI $\omega_i$ \DIFdelbegin \DIFdel{values}\DIFdelend \DIFaddbegin \DIFadd{weights}\DIFaddend .

As all \DIFaddbegin \DIFadd{$O(n\log{p})$ }\DIFaddend ORE comparisons are done between sequential sensors $i$ and $i+1$, \DIFdelbegin \DIFdel{seen in }%DIFDELCMD < \eqref{eqn:fci_eq}%%%
\DIFdel{, }\DIFdelend $L$ and $R$ ORE encryptions can be used to the same effect as for the two sensor case. The ORE ordered list sent from each sensor $i$ is given by
\begin{equation}
   \DIFdelbegin %DIFDELCMD < \begin{gathered} \label{eqn:sensor_lists}
%DIFDELCMD <       [\mathcal{E}^L_{ORE}(\omega^{(1)}\tr(\mP_i)),\dots,\mathcal{E}^L_{ORE}(\omega^{(p)}\tr(\mP_i))],\ i\text{ odd} \\
%DIFDELCMD <       [\mathcal{E}^R_{ORE}(\omega^{(1)}\tr(\mP_i)),\dots,\mathcal{E}^R_{ORE}(\omega^{(p)}\tr(\mP_i))],\ i\text{ even}\,.
%DIFDELCMD <    \end{gathered}%%%
\DIFdelend \DIFaddbegin \begin{aligned} \label{eqn:sensor_lists}
      &[\mathcal{E}^L_{ORE}(\omega^{(1)}\tr(\mP_i)),\dots,\mathcal{E}^L_{ORE}(\omega^{(p)}\tr(\mP_i))],\,i\text{ odd} \\
      &[\mathcal{E}^R_{ORE}(\omega^{(1)}\tr(\mP_i)),\dots,\mathcal{E}^R_{ORE}(\omega^{(p)}\tr(\mP_i))],\,i\text{ even}.
   \end{aligned}\DIFaddend 
\end{equation}
When combining \eqref{eqn:sensor_lists} with PHE encryptions of local information vectors and information matrices, SecFCI can be computed entirely homomorphically by \eqref{eqn:n_sen_paillier_ci_cov} and \eqref{eqn:n_sen_paillier_ci_estimate}.

\DIFaddbegin \DIFadd{Briefly considering the security of our scheme, we note that any leaked information from ORE lists }\eqref{eqn:sensor_lists}\DIFadd{, as described in \mbox{%DIFAUXCMD
\cite{chenettePracticalOrderRevealingEncryption2016}}\hspace{0pt}%DIFAUXCMD
, can be considered a subset of knowing the estimated fusion weights $\omega_1,\dots,\omega_n$, which specify relative sizes of sensor covariance traces, and we already consider public. Thus only IND-CPA and IND-OCPA (after accounting for leakage through public weights) encryptions are made available to the fusion center.
}

\subsection{\DIFadd{Computational Complexity}} \label{subsec:complexity}
\DIFadd{Given the state estimates and estimate errors at each sensor, we wish to show the computational complexity of the SecFCI algorithm for the $n$ sensor case. We will assume that both Lewi ORE and Paillier PHE schemes use the same length security parameter (and equivalently key size), such that $\lambda_{Lewi} = \lambda_{Paillier} = \log{N}$, where $\lambda_{s}$ represents encryption scheme $s$'s security parameter, and $N$ the Paillier modulus and encryptable integer limit. We also note the distinction between floating-point or small integer operations, which are typically treated as having $O(1)$ runtime, and large integer operations whose complexities are dependent on bit length. While architectures exist for speeding up encryption operations \mbox{%DIFAUXCMD
\cite{gueronIntelAdvancedEncryption2010}}\hspace{0pt}%DIFAUXCMD
, we consider software implementations and treat large integer operations in terms of bit operations explicitly.
}

\DIFadd{From \mbox{%DIFAUXCMD
\cite{paillierPublicKeyCryptosystemsBased1999,lewiOrderRevealingEncryptionNew2016}}\hspace{0pt}%DIFAUXCMD
, and the assumptions made above, we have summarized the operation complixites of the two schemes in Table \ref{tab:complex_ops}.
}\begin{table}[tb]
   %DIF > \vspace{-5pt}
   \centering
   \caption{\DIFaddFL{Computation complexity of encryption operations.}}
   \label{tab:complex_ops}
   \begin{tabular}{ |c|c| }
      \hline
      \textbf{\DIFaddFL{Operation}} & \textbf{\DIFaddFL{Complexity}} \\ 
      \hline
      \DIFaddFL{Paillier enc. }& \DIFaddFL{$O(\log{N}\log^2{N^2})$ }\\ 
      \DIFaddFL{Paillier dec. }& \DIFaddFL{$O(\log{N}\log^2{N^2})$ }\\ 
      \DIFaddFL{Paillier add. }& \DIFaddFL{$O(\log^2{N^2})$ }\\ 
      \DIFaddFL{Paillier scalar mult. }& \DIFaddFL{$O(\log{N}\log^2{N^2})$ }\\ 
      \DIFaddFL{Lewi $L$ enc. }& \DIFaddFL{$O(\log^2{N^2})$ }\\ 
      \DIFaddFL{Lewi $R$ enc. }& \DIFaddFL{$O(\log^2{N^2})$ }\\ 
      \DIFaddFL{Lewi comp. }& \DIFaddFL{$O(\log^2{N^2})$ }\\ 
      \hline
   \end{tabular}
   \vspace{-5pt}
   %DIF > \vspace{-\baselineskip}
\end{table}
\DIFadd{In contrast to some current FHE schemes, these operations are of a much lower complexity than \mbox{%DIFAUXCMD
\cite{vandijkFullyHomomorphicEncryption2010a}}\hspace{0pt}%DIFAUXCMD
, which has complexity $O(\lambda^{10})$ for integer operations, and \mbox{%DIFAUXCMD
\cite{stehleFasterFullyHomomorphic2010}}\hspace{0pt}%DIFAUXCMD
, which computes single bit operations in $O(\lambda^{3.5})$ adding significant overhead for integer arithmetic.
}

\DIFadd{Finally, applying the operations from Table \ref{tab:complex_ops} to the SecFCI algorithm, we summarize the total complexity of SecFCI at the sensors and the fusion center in Table \ref{tab:complex}, with the unencrypted complexities of FCI shown for reference. 
}\begin{table}[tb]
   %DIF > \vspace{-5pt}
   \centering
   \caption{\DIFaddFL{Computation complexity at sensors and fusion center.}}
   \label{tab:complex}
   \begin{tabular}{ |c|c|c| }
      \hline
       & \textbf{\DIFaddFL{FCI}} & \textbf{\DIFaddFL{SecFCI}} \\ 
      \hline
      \DIFaddFL{Sensors }& \DIFaddFL{$O(1)$ }& \DIFaddFL{$O\left((p + \log{N})\log^2{N^2}\right)$ }\\ 
      \DIFaddFL{Fusion }& \DIFaddFL{$O(n^3)$ }& \DIFaddFL{$O\left((\log{p} + \log{N})n\log^2{N^2} + n^3\right)$ }\\ 
      \hline
   \end{tabular}
   %DIF > \vspace{-5pt}
   %DIF > \vspace{-\baselineskip}
\end{table}

\DIFaddend % 8888888b.                            888 888
% 888   Y88b                           888 888
% 888    888                           888 888
% 888   d88P .d88b.  .d8888b  888  888 888 888888 .d8888b
% 8888888P" d8P  Y8b 88K      888  888 888 888    88K
% 888 T88b  88888888 "Y8888b. 888  888 888 888    "Y8888b.
% 888  T88b Y8b.          X88 Y88b 888 888 Y88b.       X88
% 888   T88b "Y8888   88888P'  "Y88888 888  "Y888  88888P'



\section{Simulation Results} \label{sec:results}
We have implemented a simulation to demonstrate \DIFdelbegin \DIFdel{and compare the SecFCI algorithm}\DIFdelend \DIFaddbegin \DIFadd{the accuracy of SecFCI approximating FCI}\DIFaddend . Three sensors independently measure a \DIFdelbegin \DIFdel{two-dimensional }\DIFdelend constant-speed linear process and simultaneously run a \DIFdelbegin \DIFdel{linear }\DIFdelend Kalman filter on their measurements. Estimates are \DIFdelbegin \DIFdel{then sent both unencrypted and encrypted }\DIFdelend \DIFaddbegin \DIFadd{sent both encrypted and unencrypted }\DIFaddend to a fusion center which computes the \DIFdelbegin \DIFdel{FCI and SecFCI }\DIFdelend \DIFaddbegin \DIFadd{SecFCI and FCI }\DIFaddend fusions on the received data respectively. \DIFdelbegin \DIFdel{Unencrypted estimates consist of the state estimate $\mean{\vec{x}}_i$ and covariance matrix $\mP_i$, while encrypted estimates }\DIFdelend \DIFaddbegin \DIFadd{Encrypted estimates }\DIFaddend are comprised of PHE encryptions of the information vector \DIFdelbegin \DIFdel{$\mathcal{E}(\mP^{-1}_i\mean{\vec{x}}_i)$ }\DIFdelend and information matrix\DIFdelbegin \DIFdel{$\mathcal{E}(\mP^{-1}_i)$, and }\DIFdelend \DIFaddbegin \DIFadd{, $\mathcal{E}(\mP^{-1}_i\mean{\vec{x}}_i)$ and $\mathcal{E}(\mP^{-1}_i)$, in addition to }\DIFaddend the ORE list given by \eqref{eqn:sensor_lists} \DIFaddbegin \DIFadd{with discretization step $s=0.1$. Unencrypted estimates consist of the state estimate $\mean{\vec{x}}_i$ and covariance $\mP_i$}\DIFaddend . The trajectory and fused estimates are shown in Fig. \ref{fig:fci_secfci_traj}.
\begin{figure}[tb]
   \DIFdelbeginFL %DIFDELCMD < \vspace{-5pt}
%DIFDELCMD <    %%%
\DIFdelendFL %DIF > \vspace{-5pt}
   \DIFaddbeginFL \vspace{-10pt}
   \DIFaddendFL \begin{center}
      \input{images/fci_secfci_cmp.pgf}
   \end{center}
   \DIFdelbeginFL %DIFDELCMD < \vspace{-10pt}
%DIFDELCMD <    %%%
\DIFdelendFL \DIFaddbeginFL \vspace{-15pt}
   \DIFaddendFL \caption{Tracking simulation comparing \DIFdelbeginFL \DIFdelFL{FCI and }\DIFdelendFL SecFCI \DIFaddbeginFL \DIFaddFL{and FCI}\DIFaddendFL .}
   \DIFaddbeginFL \vspace{-\baselineskip}
   \DIFaddendFL \label{fig:fci_secfci_traj}
\end{figure}

\DIFdelbegin \DIFdel{The traces of the fused covariance matrices from both FCI}\DIFdelend \DIFaddbegin \DIFadd{To derive an upper bound on the accuracy difference between SecFCI and FCI, we note the two factors which introduce inconsistency between the two methods. Encoding from section \ref{subsec:complexity}, and the difference in fusion weights. Due to the possibility of choosing sufficiently large integer and fractional bit lengths $i$ }\DIFaddend and \DIFdelbegin \DIFdel{SecFCI fusion are shown in Fig. \ref{fig:fci_secfci_trace} where a very small difference in trace can be seen. As SecFCI approximates FCI which in turn is an approximation to the CI's trace minimization function }%DIFDELCMD < \eqref{eqn:ci_trace_min}%%%
\DIFdel{, neither method guarantees a resulting trace smaller than the other.
}%DIFDELCMD < \begin{figure}[tb]
%DIFDELCMD <    \vspace{-5pt}
%DIFDELCMD <    \begin{center}
%DIFDELCMD <       \input{images/traces_cmp.pgf}
%DIFDELCMD <    \end{center}
%DIFDELCMD <    \vspace{-10pt}
%DIFDELCMD <    %%%
%DIFDELCMD < \caption{%
{%DIFAUXCMD
\DIFdelFL{Traces of fused covariance matrices for FCI and SecFCI.}}
   %DIFAUXCMD
%DIFDELCMD < \vspace{-\baselineskip}
%DIFDELCMD <    \label{fig:fci_secfci_trace}
%DIFDELCMD < \end{figure}
%DIFDELCMD < %%%
\DIFdel{Values of each }\DIFdelend \DIFaddbegin \DIFadd{$f$, we will only consider the error caused by the difference in weights. We will treat this error as the distance between respective weight vectors
}\begin{equation}
   \DIFadd{\begin{aligned}
      &\vec{\omega}_{SecFCI} = (\omega_{1,SecFCI},\dots,\omega_{n,SecFCI})\,, \\
      &\vec{\omega}_{FCI} = (\omega_{1,FCI},\dots,\omega_{n,FCI})
   \end{aligned}
}\end{equation}
\DIFadd{where $\omega_{i,s}$ denotes weight }\DIFaddend $\omega_i$ \DIFdelbegin \DIFdel{over time }\DIFdelend \DIFaddbegin \DIFadd{from algorithm $s$. From section \ref{sec:secfci} we see that the largest difference $|\omega_{i,FCI} - \omega_{i,SecFCI}|$ is strictly bounded by $s/2$. Section \ref{sec:multi_secfci} shows that when more sensors are involved, a tighter bound on this difference is dependent on the value of $\vec{\omega}_{i,FCI}$, but will remain strictly bounded by $s/2$. Therefore, we can give a strict upper bound on the distance between weight vectors as
}\begin{equation}
   \DIFadd{|\vec{\omega}_{FCI} - \vec{\omega}_{SecFCI}| < 0.5\sqrt{ns^2}\,. \label{eqn:accuracy_error_bound}
}\end{equation}

\DIFadd{Finally, components of $\omega_{i,SecFCI}$, $\omega_{i,FCI}$ and the errors $|\vec{\omega}_{FCI} - \vec{\omega}_{SecFCI}|$, }\DIFaddend have been plotted \DIFaddbegin \DIFadd{over time }\DIFaddend in Fig. \ref{fig:fci_secfci_omegas}\DIFdelbegin \DIFdel{. Due to discretization, as can be expected, SecFCI values of $\omega_i$ stay constant but may jump with sufficient change in true FCI $\omega_i$ values, as can be seen near the start of the simulation}\DIFdelend \DIFaddbegin \DIFadd{, and show the commputed error bound when $n=3$ and $s=0.1$}\DIFaddend .
\begin{figure}[tb]
   \DIFdelbeginFL %DIFDELCMD < \vspace{-5pt}
%DIFDELCMD <    %%%
\DIFdelendFL %DIF > \vspace{-5pt}
   %DIF > \vspace{-10pt}
   \begin{center}
      \input{images/omegas_cmp.pgf}
   \end{center}
   \DIFdelbeginFL %DIFDELCMD < \vspace{-10pt}
%DIFDELCMD <    %%%
\DIFdelendFL \DIFaddbeginFL \vspace{-15pt}
   \DIFaddendFL \caption{\DIFdelbeginFL \DIFdelFL{FCI }\DIFdelendFL \DIFaddbeginFL \DIFaddFL{$\vec{\omega}_{SecFCI}$ }\DIFaddendFL and \DIFdelbeginFL \DIFdelFL{SecFCI $\omega_i$ values and their difference}\DIFdelendFL \DIFaddbeginFL \DIFaddFL{$\vec{\omega}_{FCI}$ components}\DIFaddendFL .}
   \vspace{-\baselineskip}
   \label{fig:fci_secfci_omegas}
\end{figure}

%  .d8888b.
% d88P  Y88b
% 888    888
% 888         .d88b.  88888b.   .d8888b
% 888        d88""88b 888 "88b d88P"
% 888    888 888  888 888  888 888
% Y88b  d88P Y88..88P 888  888 Y88b.    d8b
%  "Y8888P"   "Y88P"  888  888  "Y8888P Y8P



\section{Conclusion} \label{sec:conclusion}
FCI is a commonly used, \DIFaddbegin \DIFadd{and }\DIFaddend efficiently computable, approximation to the CI optimization problem that requires the sharing of local sensor estimates to compute their fusion. We propose a secure approximation to FCI, SecFCI, to compute the fused estimate homomorphically. The novel encrypted \DIFdelbegin \DIFdel{signal processing }\DIFdelend \DIFaddbegin \DIFadd{fusion }\DIFaddend approach may find uses in various security-critical applications or over untrusted networks. Possible future work includes \DIFdelbegin \DIFdel{a }\DIFdelend run-time \DIFdelbegin \DIFdel{comparison between SecFCI and potential }\DIFdelend \DIFaddbegin \DIFadd{comparisons with }\DIFaddend FHE implementations, giving a computational bound for its practicality\DIFdelbegin \DIFdel{. Also, we hope to further quantify ORE leakage concerning SecFCI fusion and produce }\DIFdelend \DIFaddbegin \DIFadd{, and quantification of fusion weight leakages via }\DIFaddend formal security proofs\DIFdelbegin \DIFdel{and assumptions for the novel algorithm}\DIFdelend .

\bibliographystyle{IEEEtran}
\DIFdelbegin %DIFDELCMD < \bibliography{IEEEtranBST/IEEEabrv,BibTeX/secure_FCI_cdc2020}
%DIFDELCMD < %%%
\DIFdelend \DIFaddbegin \bibliography{IEEEtranBST/IEEEabrv,BibTeX/IEEEBibControls,BibTeX/secure_FCI_cdc2020}
\DIFaddend 

\end{document}
